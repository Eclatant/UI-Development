# HTML & CSS 스터디_Bsidesoft

[Youtube](https://goo.gl/QNv58c), [후기](http://www.bsidesoft.com/?s=S68), [페이스북 그룹](https://www.facebook.com/groups/dgding)

## 맹대표님 글 - 1
개발이라는 것을 보는 관점을 두 가지라고 해봅시다.
　
먼저 "내가 원하는 개발물을 얻는 행위" 라는 관점입니다. 이 관점에서는 발주를 해도 개발을 했다고 할 수 있을 것입니다. 즉 "이해를 못해도 일단 굴러가면 된다" 라는 관점입니다. 붙여넣고 가져오고 따라하면 굴러가니 만족이다! 라는 것이죠.
　
사실 공부할 때 초반 당근으로 이런 것이 꼭 필요하긴 합니다만 단지 이걸 위해서 코딩을 공부할 필요는 없습니다. 이런 건 발주하거나 솔루션을 구입하면 되니까요.


그럼 다른 관점에선 어떨까요?
　
개발물이 왜 작동할까? 에 대해 공부해가는 과정이라 할 수 있습니다. 우리가 왜를 배우려는 이유는 완전한 지식(그런게 존재하는지 모르겠지만)에 도달하기 위해서가 아닙니다.
　
보다 많은 왜를 답할 수 있게 될수록 → 응용하여 만들 수 있는 개발물의 범위가 넓어지기 때문입니다. 해서 공부를 할 때 어디까지 왜를 설명할 수 있을지 수준을 정해야겠죠.
　
물론 반도체가 왜 작동하는지까지 내려가지는 않을 겁니다. 반대로 그냥 구글이 훌륭해서 잘된다 레벨로 무관심하지도 않겠죠. 그렇다면 어디가 적당할까요?
　
그 적당한 왜의 레벨을 이번 스터디에서는 교재에 등장하는 내용에 맞춥니다. 교재에 등장하는 예제가 왜 그렇게 작동하는가를 설명할 수 있는 수준까지는 공부를 해보자는 거죠.
　
교재에 대해 이야기 해볼까요?
　
이 교재는 의외로 어렵습니다. 따라하면 화면이 나오긴 하지만 왜 그렇게 되는지에 대한 설명은 절반도 안해주는 편입니다.
　
제한된 2시간 내에 얼마나 자세히 설명할 수 있을지 잘 모르겠지만, 확실한 건 여러분이 개발경험이 없고 HTML, CSS에 관련 지식도 없다는 걸 기반으로 설명하니까 적지 않은 분량일 것입니다.
　
적어도 스터디 오기 전에 책을 읽고, 책에 있는 예제를 직접 쳐서 실행보신다면 같이 스터디를 꾸려가는데 큰 도움이 되겠죠.
　
반대로 "그래도 아무것도 안하는것보단 낫겠지?" 하고 당일날 시간을 떼우러 오시면 1, 2회차에는 뭔가 들리는 것도 있겠지만, 이내 곧 알 수 없는 레벨로 어려워질거에요.
　
모든 책의 구성은 뒤로 갈수록 어려워지는게 아닙니다.
요점은 뒤의 내용은 앞의 내용을 기억하고 있다는 것을 전재로 기술되어있다는 것입니다.
　
따라서 한주 한주 배울 때마다 그것을 외우지 않는다면 후반 수업은 도저히 알아 먹을 수 없게 될 것입니다(이게 계속 복습과 암기를 미루고 미루다가 후반에는 포기하는 전형적인 많은 사람들의 공부죠 ^^)
　
부디 열공하셔서 컴알못에서 개발자로 한단계 나아가실 수 있기를 바랍니다 ^^

## HTML & CSS 스터디 1강

대체되지 않으려면 회사 외적으로도 공부를 많이 해야만 한다

연봉이 올라가면, 인력을 유지해야 할 이유가 없다면 짤린다


그래픽스 시스템, 렌더링 시스템이란 무엇일까?

그래픽스 시스템의 기본은 점을 찍는 것이다
- 점은 하나 하나 식별할 수 있으니, 그것들을 수치적으로 인식할 수 있다

### fixed number
- 정형화 되있는 좌표를 가지고 점으로 숫자나 그래픽을 그릴수 있음
- 단점으로는 만들 때도 업데이트할 때도 모두 힘들다는 것

### Abstract Calculator
- Intro
  - Context: 왠지 대상들이 공유하고 있는 비슷한 것들의 집합, 문맥이라고 번역하기엔 부적절(차라리 맥락이 더 맞을 것)
  - 공부의 근본은 단어의 명확한 정의를 알게 되는 것
  - 영어는 같은 일반명사를 컨텍스트마다의 고유명사로 사용해서 어렵다
  - 공부라는 것은 단어를 정복해가는 과정, 단어를 이해하게 되면 공부가 된 것
  - 또한 공부의 판가름은 암기를 했냐에 달려있다
  - 비율이나 위치 등의 Context에 맞는 그래픽을 구현하고 싶음
  - 추상적인 개념들을 기저 시스템(fixed number)을 기반으로 구현하고자 하는 것이 abstract calculator
  - right를 구현하려면 당연히 컴퓨터는 화면의 사이즈를 알고 그것에 맞는 left값을 부여할 수 있어야 하기 때문
  - 또한 부모 계층구조도 계산되어있어야 한다
- UI가 차지하고 있는 공간을 Chrome이라고 한다, 자동차 문 밑에 붙여져있는 그 것
  - 브라우저 전체 크기에서 Chrome Size를 빼면 Screen Size가 된다
- 컴퓨터에게 굉장히 많은 연산을 맡기는 대신, 우리는 추상적인 표현을 얻을 수 있다
  - 환경에 맞춰 컴퓨터가 자동으로 연산한다
- 책에서 다루는 내용들은 Fixed number가 아니지만, 우리가 공부해야 하는 과정은 추상적인 개념들이 무엇을 의미하고, 구체적으로 화면에서는 어떻게 그려지는지를 이해하는 과정이다

### Component
- 계산 로직이나 구현과정은 모두 감춰져있고, 오직 목적만이 기술해서 사용할 수 있다
- 단순한 기능 구현에 그치는 것이 아니라, 우리가 공감할 수 있는 고유명사를 구현해낸 것
- 그러나 유기적이지 않다 => Framework

추상화된 컨텍스트를 인식하는 방법과, 일부 컴포넌트를 익히는 것이 이 책의 목표

### Rendering System

위의 원론적인 내용들을 실제로 구현하는 것은 렌더링 시스템
- 시각화되어있지 않은 것(코드 등)을 시각화시키는 것을 렌더링이라고 한다

### Geometric Calculator

그림을 그리기 전에 해야 하는 일은 어디에다가 무엇을 그릴지 영역(geometry)을 잡아주는 것

어느 사이트를 만나면, 제일 먼저 인지해야 하는 것은 공간을 어떻게 나누었는지이다
거듭 사각형을 분리해보는 연습을 하세요

채우는 것은 하나 하나 채워나가면 된다, 더 중요한 것은 Geometry calculating을 할 수 있도록 공간계획을 세우는 것
코드를 공간(지형)을 계산하여 나눈다

플랫폼마다 각기 다른 방식으로 나누지만, 그 과정 자체를 잘 익히면 어느 시스템에서든 잘 할 수 있다

### Fragment Fill

Fragment는 화면의 픽셀이며, Fragment Fill 화면의 픽셀들을 채워가는 행위를 뜻한다

즉 순서는, Geometry를 계산하고, Fragment를 채워가는 것

HTML은 텍스트 렌더링에 대단히 강했고, 원래 반응형에 적합하지 않았지만, 갈수록 화면 크기로부터 자유로워져가고 있다
HTML Component는 Form에 강점이 많다, 다른 시스템에 비해서 Image는 많이 느리다


컴퓨터는 아직까지는 상세히 알려주어야 합니다
자동으로 되는 것은 없다
반대로 CS의 특성은 공리나 가정이 없다는 것
예를 들면 수학은 태초에 0이 있다라는 공리에서부터 출발합니다
태초에 어떤 법칙이 있다라는 가설에서 시작되며, 그것에 대해 완전히 설명할 수 없습니다
공리까지 파고 들어가면, 가정이자 믿어야만 하는 것 즉 패러다임이라고 합니다
패러다임이 변하면, 공리가 바뀐다는 것
자연과학에 패러다임이 존재하는 것은 공리가 있기 때문이다
그에 비해 CS는 언제나 재현가능하고, 설명 가능합니다
컴퓨터의 가장 기저에는 보일러 대수학이 있습니다
CS는 공리가 없기 때문에 다른 과학적인 내용들보다 훨씬 쉽습니다, 설명할 수 있습니다
단점은 지식이 점진적으로 쌓인다는 것
삼단논법이 127단있다고 생각해보시면 됩니다, 앞에 있는 것들을 모두 이해하지 못 하면 뒤를 이해할 수 없습니다
컴퓨터를 공부할 때 자기 성향과 안 맞는다고 생각할 수 있는 부분입니다
노력을 지속적으로 기울일 수 있고 암기까지 갈 수 있는 분야를 찾아야 합니다
많은 개발자들이 HTML & CSS를 잘 못 하는 이유는 이 분야에 대해서 노력을 하고 싶은 생각이 별로 들지 않기 때문입니다
취향이 맞냐 안 맞냐가 중요합니다, 내 취향을 노력을 통해 여기에 일치시킬거야 라는 마음이 드시면 성공하실 수 있을 것입니다
CS는 쌓여있는 기존 로직을 공부하고 그것을 기반으로 점진적으로 쌓아나가야 합니다
추론력이 뛰어나다고 갑자기 이해할 수 없고, 암기가 필수적입니다, 이 책도 그냥 다 외운다고 생각하세요
암기 안 하면 3~4장부터 못 따라가실거에요
100단어를 외우고 싶다면, 첫 날 10단어 그 다음 날 20단어 와 같이 계속 앞의 단어를 데리고 가면서 공부하는 것

// 쉬는 시간

이제부터 Layout과 Geometry는 동의어에요
단, Geometry는 기계적으로 컴퓨터를 통해 구획하는 것이라면, Layout은 보다 하이레벨의 다양한 의미와 의도가 담겨있어요

사실 배치보다는 영역을 잡아간다는 것이 더 중요합니다, 배치는 왠지 XY만 움직이는 것 같다, 실제로는 크기도 잡아야 하고 관계도 잡아줘야 합니다, 배치라고 말하기 어렵습니다

HTML은 원래 인쇄 문서를 만들기 위한 포맷이에요

HTML이 발전해가면서, 아래와 같이 변화하게 된다 (b -> strong)
의미는 HTML으로 부여하고, 표현은 CSS에게 위임한다(의미와 표현의 분리)

완전 기능적인 태그들(audio, video, img 등), 의미가 없는 태그들(div, span 등 모양을 입히기 위해 만드는 태그)
div의 반복 대신에 용도에 맞는 태그들이 HTML5에서 만들어짐(nav, footer 등)

div와 같은 태그는 거의 나오지 않는 것이 정상이다
div가 많아지는 것은 CSS를 잘 못하기 때문이다

Class는 스타일과의 바인딩을 위해 사용한다
HTML은 CSS를 가르킬 방법이 없지만, CSS는 Selector를 통해 HTML을 선택할 수 있다
스타일시트는 스타일 자체에 대한 기술과 셀렉터의 조합으로 이루어져있다, 이것을 Rule이라고 부른다
Rull을 모은 것을 Rullset, Rullset을 소유하고 있는 소유체를 Sheet라고 부른다, 이 소유체가 하는 일이 스타일을 정의하는 것이기에 Style Sheet라고 부른다(Sheet안에는 룰셋 말고도 미디어쿼리 등 다양한 것들이 있다)

HTML은 각 태그의 기본적인 모양들이 정의된 기본 Sheet를 가지고 있다
덮어쓰기가 가능하기에, 마지막 셀렉터의 스타일이 적용된다 (우리는 기본 스타일시트에 덮어쓰기하고 있는 것)

Selector 방법
- Nth child : 관리하기 매우 까다롭다 (Fixed Number와 비슷)
- Tag
- Class : 공통점을 그룹화해서 부여, 띄어쓰기를 통해 동시에 여러 클래스 부여 가능, StyleSheet는 무조건 뒤가 이긴다(덮어쓰기가 기본이기 때문), 왼쪽에서 오른쪽 순으로 진행되기 때문에 오른쪽에 부여된 클래스가 적용된다

사물을 직접적인 이름으로 부르게 되면, 대체 불가능하거나 수정하기 매우 어려워진다 (Example: Index값)
추상화되어있는 이름으로 부르게 되면, 대체할 수 있다

컴퓨터세상에서 유일하게 할당만이 오른쪽에서 왼쪽으로 가는 행위

고유한 이름을 부여할 때는 ID를 사용할 수 있지만, 개발을 나 혼자만 하지 않기 때문에 고유성이 필요한 ID는 사용하지 않아요(해당 ID를 나 말고도 부여할 수 있기 때문에 위험해요), 때문에 고유하더라도 Class를 사용해요
해서 Class의 기준은 두 개 이상이 아닌 한 개 이상인 것이에요

어떤 레이아웃은 태그가 더 추가적으로 들어가야만 만들 수 있어요
태그가 얼마나 적게 사용했느냐를 보고 실력을 알 수 있다
레이아웃만을 위한 태그가 최소화되어야 좋다

DOM구조에서 자식이면, 부모의 CSS를 상속받아요
단, 상속받는 CSS가 있더라도, 자신이 가지고 있는 CSS가 있다면 덮어버립니다.

덮어쓰기와 더불어 다른 규칙이 하나 더 있는데, 더 구체적으로 Selecting된 스타일이 적용됩니다
구체적인 셀렉터가 범용적인 셀렉터를 이깁니다
셀렉터는 직계 자식이 아니더라도 적용됩니다

컴퓨터는 규칙대로 움직이기 때문에, 모두 설명 가능하지만 달리 말하면 대충 알고 있다면 제대로 설명할 수 없습니다, 상세하게 설명할 수 있다면 마음대로 할 수 있습니다, 왜 그렇게 되었는지도 설명할 수 있습니다, 이 레벨이 되기까지 위해 수없이 질문하고 공부해보세요, 이것을 건너뛰게 되면 어느 순간 아무 것도 알 수 없게 되어요, 많은 왜에 대해서 그냥 건너뛰지 마시고 수없이 질문하세요

Block = 부모가 허용하는 될 수 있는 한 가로를 다 차지하는 것
Body는 원래 Margin값을 가지고 있다

Inline
- Inline 내에서 가장 큰 Height를 가진 아이가 그 Inline의 Height를 결정합니다
- 자기의 X에 Width를 더한 값이 다음 Inline의 X가 됩니다
- 부모의 남은 공간에 들어올 수 있다면 들어오고, 그렇지 않으면 다음 번 Baseline으로 내려간다
    - Baseline은 Height가 가장 큰 것을 기준으로 정해진다
- 공간의 여유가 있다면 앞 요소의 바로 오른쪽에 들어감

Block인지 Inline인지를 지칭하는 개념을 Display라고 합니다
Inline은 대단히 추상화되어있는 고유명사(Fixed Number로 계산하면 얼마나 복잡하겠는가)

div는 기본 스타일시트로 block으로 주어져있어요(W3C 기본 명세서)

Float를 이해하려면 display를 이해해야 합니다
Float는 대부분의 개발자들이 CSS를 포기하게 만드는 장벽이에요
Float를 상세하게 이해하고 쓰는 퍼블리셔는 매우 드물지만, 잘 쓰면 재밌고, 화면 크기에 대응하는 웹 사이트를 만들 때, 화면크기별 대응에 굉장히 유용해요
Float가 대체 어떤 속성이길래 반응형 웹에 유용하게 쓰일까요?
마음대로 움직여서 예쁘게 보일 수 있다는 것은 굉장히 많은 변화를 여러분이 통제해야 한다는 것이에요
잘 통제하면 이쁘게 되겠지만 그만큼 어렵다는 얘기겠죠

Float는 떠있다(Layer), 그러면 떠있지 않은 것은?
떠있지 않은 것은 실체라고 하고, Geometry 영역상에 공간을 확보하고 있는 것들이다
Float는 대표적으로 실체가 없는 애에요(공간을 점유하지 않아요)
공간을 점유하려면 반드시 실체가 있어야 해요
Float는 공간을 점유하고 있지 않기 때문에 사이즈가 늘어나지 않는다

Float는 Block과 Inline에 주는 영향이 달라서 어렵다
Float는
- Block에 영향을 주지 않는다(Block은 Float를 인식할 수 없다)
- Inline에 가드 || 가이드로 작용한다
- Float끼리는 Inline처럼 움직인다
    - right일 때는 오른쪽으로의 번호표를 가장 먼저 받은 애가 가장 오른쪽

어떻게 추상화되어있는지를 알아야 정확히 쓸 수 있다
다만 논리가 있는 것이 아니라 정해져있는 규칙을 암기하는 것이다
우리가 원하는 위치를 잡으려면, 추상화된 아이들을 규칙에 따라 조합해야 한다
퍼블리싱이 어렵고, 입문이 어렵고, 개발자들이 포기하는 이유가 이것이며, 주먹구구로 배우기 어려운 이유다

https://brunch.co.kr/@techhtml/21

---

## 맹 대표님 글 -2

스터디를 하다보니....html과 css에 대해 너무 모르는게 많다. 이렇게 아는게 없었다니 굉장히 반성하고 있다....라고 끝내면 안될거 같고 ^^;
　
구체적으로는 사람은 보통 아는 만큼 보이기 마련인데 이 말은 반대로 생각해보면 잘 모르는건 직관적이고 피상적으로 파악하기 때문에 그렇다. 
하지만 어떤걸 잘 알려면 잘 모르는 것을 연구해서 잘알게 되는 것이므로 피상적이거나 그냥 넘어가던걸 섬세한 관찰과 생각을 통해 재발견하는 수 밖에 없다.
　
대표적으로 css의 셀렉터를 보자. 너무나 친숙하고 익숙하기 때문에 css의 셀렉터가 작동하는 방법을 알고 있다고 생각하고 습관적으로 쓰고 있다.
하지만 실상은 셀렉터간의 우선순위를 구체적으로 설명할 수 없다.
심지어 스터디 시간에도 초보자를 상대로 판 약이란게 '긴게 이긴다' 정도다.
물론 입문자를 상대로야 수영을 가르치는 요령으로 쉽게 적응시킨뒤 구체적으로 가르치는 편이 동기부여나 도입부의 장벽을 낮출 수 있으니 그나마 변명거리가 되겠지만,...
　
문제는 그래서 진짜로는 내가 아냐는 거다.
　
아마 단 한번도 이것을 원리적으로 생각해본 적이 없는거 같다. 각 상황별 현상을 알고 단편적인 경험을 채워서 사용하는 지극히 피상적인 상황인 것이다.
　
하지만 컴퓨터가 움직일때 기저에 깔린 알고리즘이 없을리 없다. 스펙에서는 
　
금메달 - 선택자에 등장한 id의 갯수
은메달 - 선택자에 등장한 다른 속성과 가상 클래스의 갯수
동메달 - 선택자에 등장한 태그 및 가상 엘리먼트의 갯수
　
로 각각 메달별로 집계하여 올림픽과 마찬가지로 금메달이 1개라도 있으면 은메달 100개를 이기는 식으로 우선순위가 결정된다. 
　
즉 div.color 가 div를 이기는 이유는
금0-은1(클래스속성)-동1(div) 과 금0-은0-동1(div) 를 비교해서 은메달이 이겼기 때문이다.
　
div div a는 간단히 #id 에게 금0-은0-동-3과 금1-은0-동0 의 비교로 간단히 져버리는 것이다.
　
이렇게 보면 HTML의 title은 모든 태그에 존재하는 기본속성인가? 그렇다면 모든 태그에 존재하는 기본속성은 전체적으로 무엇이 있는가? 등등 기본적인 질문과 스펙을 내가 답할 수 있는게 별로 없다.
　
즉 걍 피상적으로 알고 있는 것이다.
그게 다른 것들에 대한 거라면 괜찮지만 내 업과 관련된 기저에 깔린 지식들에 대해서 그렇게 당연하게 무시하면서 살고 있다는 점에 반성을 많이 한 요즘이었다.

---

## HTML & CSS 2강

처음 배우는 사람들일수록 왜 배우는지 명백하지 않으면 공부하기 어렵다

저번 시간에 그래픽스와 렌더링에 대해 배웠다, 웹 뿐만 아니라 굉장히 일반론적인 부분들이에요

HTML 스펙 문서에 HTML이 어떻게 그려지는지 나와있어요
브라우저는 모두 그 스펙 문서에 기반해서 만들어져있지만, 어렵고 딱딱해서 개발자조차 안 읽어요
문제가 생기거나 헷갈리면 기준이 되는 스펙문서를 찾아가는 습관을 들여야 해요

개발자적인 사고란 남이 만들어놓은 것이 무엇인지 정확하게 이해하는 것이에요

CS에서 제로부터 만드는 것이 없어요, 남이 만든 것을 정확히 이해하지 못 하기 때문에 엉망으로 쓰는 거에요

전체를 바라볼 수 있는 시각이 없다면 원래 만들어진 방식이 아닌 자기 나름의 방식으로 사용하게 되는 것이에요

그런데 실제로는 스펙 문서로 모두 실존하는데, 그것을 안 읽고 대충 대충 부분적으로 가져다쓰려고 하는 것이 사람의 심리에요

회사의 개발중인 소프트웨어를 바라보면 유리같은 느낌을 받지 않나요? 시나리오대로만 작동하고 거기서 조금만 비틀면 툭하고 깨질 것만 같은, 테스트 한 번 거치면 다 깨지고-
그렇게 만들어진 이유들은 원리와 스펙대로 개발한 것이 아니기 때문이고, 만약 그대로 따랐다면 경우의 수가 없는 개발이 됩니다
스펙대로가 아니라 본인만의 노하우들로 만들게 되면 경우의 수가 생기고, 정해진 시나리오에서 조금만 벗어나면 깨져버리는, 취약한 개발이 됩니다

경우의 수를 만들지 않으려면, 바른 방법, 원래가 무엇인지 알고 개발해가야 합니다, 그러려면 원리학습을 해야 합니다

Box Model, Normal Flow, Display와 Float가 어떻게 작동하는가?

Box model이란 개별 Element가 지오메트리 공간을 얼마나 차지할지 결정하는 기본적인 원리라고 할 수 있어요
그에 비해서 Normal Flow라는 것은 Box Model대로 결정되어있는 박스들을 어떻게 배치할 것인가에 관한 것이라고 할 수 있어요
Normal Flow는 공식에 의해서 그려지는데, 거기에 영향을 끼치는 중요한 두 가지 요소가 Display와 Float입니다

원리를 깨닫고 나면, HTML이 어떻게 렌더링되는지 좀 더 알게 됩니다

시스템마다 고유한 렌더링 시스템이 있어요
브라우저가 각각의 Element를 어떻게 배치하는지 알아야지만 헷갈리지 않게 쓸 수 있어요

아래의 예제코드는 매우 쉬운 것인데도, 제대로 이해하기 어려우실거에요

<div style="background:rgb(39,241,188)">
    <div style="float:left;width:100px;height:100px;background:#f00">
        <div style="margin:10px;float:left;width:50px;height:200px;background:#ff0"></div>
    </div>
    sample inline text. sample inline text. sample inline text. sample inline text. sample inline text.
</div>

<div style="clear:both;margin-bottom:200px"></div>

<div style="overflow:hidden;background:rgb(39,241,188)">
    <div style="float:left;width:100px;height:100px;background:#f00">
        <div style="margin:10px;float:left;width:50px;height:200px;background:#ff0"></div>
    </div>
    sample inline text. sample inline text. sample inline text. sample inline text. sample inline text.
</div>


### Box Model

#### Margin
- 박스를 감싸고 있는 영역
- 실제 그려지는 영역이 아니라 Space를 확보하는 영역이에요
- 더 높은 수치를 줄수록 다른 박스와의 간격을 확보할 수 있어요

#### Border
- 외곽선
- 상상력을 발휘한다면 margin없이 border만 늘려서 같은 효과를 볼 수 있어요

#### Padding
- 외곽선을 기준으로 안쪽의 Content-Box까지의 Space를 주는 행위
- Box 안쪽에 공간을 주고 싶다 => Padding
- 하지만 Margin과 Padding은 굉장히 다른 특성을 가지고 있어요

#### Contents
- Margin, Border, Padding을 빼고 남은 공간이 Contents에요

일반적인 CSS 2.1 기준으로는 (아무 설정도 하지 않았을 때) Contents 영역의 width&height를 width&height로 보고 있어요
그래서 width를 100주면 Contents 영역에 준 것이 되어요

width 100주고, Padding을 2주고, Border를 1주면 외곽선으로부터 가운데까지는 103이 되어요
이때 문제가 되는 지점은, 만약 Contents에 숫자가 아닌 %를 주게 되면 부모를 다 차지하게 되어요(100%를 줄 경우)
게다가 Padding과 Border를 부여해주게 되면 100%가 넘어서서 스크롤바가 생겨버려요

그래서 CSS3부터는 박스를 계산하는 모델에 대해서 다른 관점을 가지고, 보다 포괄적으로 정의하기로 했어요
박스의 크기를 결정할 때 Contents를 기준으로 결정하는 것이 아니라 어떤 박스를 기준으로 설정할지 선택할 수 있는 로직이 생겨났어요
기존 로직은 `box-sizing : content-box` 라고 부여되었던 것
(이것이 기본 값이므로, box-sizing 설정 없이 width, min-width, max-width를 설정하면 Contents-box를 기준으로 하는 의미가 되어요)

`box-sizing: padding-box` 라고 부여해주면 padding-box까지의 크기나 높이를 계산하게 될 것
아직까지 제안 중인 프로퍼티여서 Firefox 외에는 동작하지 않는다

마지막으로 border-box가 있는데, 역시 width, height를 부여하면 border를 포함하는 영역에서 역산해서 크기를 가지게 된다
Border가 2, Padding 5이면, 나머지 영역인 Contents는 100%에서 7이 제외된 크기겠죠

그러니 Border Box 크기를 포함한 width&height를 주고 싶다면, 반드시 box-sizing을 border-box로 변경한 뒤에 width&height를 주어야 해요

개발의 대부분은 외우는 것입니다, 개발이 어려운 것은 노력과 비례하기 때문일 수도 있어요
반짝이는 총기라던지, 높은 IQ 등으로 해결이 잘 안 됩니다
외우는 양에 비례해서 개발실력이 좋아지고, 체계적으로 외웠느냐 외운 것들이 서로 부딪히지 않고 잘 쌓여있느냐에 따라 개발실력이 결정됩니다

지식의 붕괴라는 상황을 아시나요? 체계성없이 공부하게 되면 왜를 알 수 없어서 지식들끼리 부딪히면서 점점 더 안드로메다로 향하게 됩니다
이 상황을 피하려면 체계적인 지식으로 학습하는 수 밖에 없습니다
체계성 있는 지식을 차근차근 외우는 것이 개발에 입문하는 유일한 방법입니다
오만하고 커뮤니케이션을 약한 개발자들이 있는 이유는, 자기들이 쌓아놓은 것이 있다고 자만하기 때문이에요
하지만 끊임없이 체계를 갱신하고 공부하는 것이 개발자의 삶이라서 쉽지 않아요

자기가 안다라고 생각하는 것이 가장 위험해요
좀 쓸 줄 안다라는 얘기는 굉장히 자만하는 얘기에요
오히려 숙달된 사람들이 자기가 원래 쓰던 방식만 고수하면서 굉장히 느리게 작업하는 경우도 있어요
본인이 안다라고 생각할 때가 가장 위험할 때가 있다는 점을 명심하세요, 한 번 아는 것부터 점검해보세요

Margin 기준은 없어요, Margin영역은 Contents가 그려지는 영역이 아니고 비가시적 영역이기에-
Margin 기준의 박스를 설정하고 싶을 때는 외곽선을 투명하게 만들고 Border를 늘립니다, 그리고 width를 100, 200 주면 Margin과 같은 효과가 나옵니다

Border를 0을 주면 안 보이는 것처럼 100을 주고 투명한 색을 부여해서 활용하면 됩니다
그런데 위와 같은 니즈는 Padding을 활용한 것과 같습니다

물론 Margin은 Contents의 Width에 영향을 끼치지 않고 공간을 확보합니다
Padding을 주면 Contents의 길이가 전체적으로 늘어나버립니다
그래서 실무에서 선택하는 솔루션은 Margin쪽이 더 많습니다
Padding은 Contents Box의 크기를 늘려버리기 때문에 어려운 점들이 발생합니다

### Normal Flow

우리가 접하게 되는 모든 단어는 고유명사에요
어떤 고유명사인가?

위치를 잡는 Model중에 CSS 초기 버전에 가장 유행했던 Model은 Static Positon Model이다
여기서 static이란 고정되어있다는 의미가 아니라 사용자는 관여하지 않고 컴퓨터가 알아서 그린다는 의미이다
나중에 나오는 relative absolute fixed는 사용자가 직접 어디에 그릴지 결정하겠다는 얘기
Static Position 내에서 그림을 그리는 방법이 Normal Flow
알아서 배치해주는 모델 내에서의 그림을 그리는 방법이 Normal Flow

세로 기준 배치(Block)와 가로 기준 배치(Inline)로 나누어 그려진다

Normal Flow의 첫 번째 동작은 BFC(Block Formatting Context)를 형성하는 것
BFC란, 여기에 있는 애들은 모두 내가 세로로 배치할거야 라는 컨테이너
IFC란, Inline Formatting Context은 무조건 가로로 배치
일반적으로 IFC는 BFC안에서 작동됨

블록 요소들을 배치할 수 있도록 하는 컨테이너(BFC)가 존재한다
BFC와 Block 요소는 다른 것이다
Body Tag가 바로 BFC에요, Body에 div Tag를 넣었기에 세로로 쌓이기 시작하는 것이에요

컴퓨터가 마법을 부리지 않는다고 생각하세요,
비개발자 분들이 착각하시는 것중 하나는 컴퓨터에 대해 난 잘 모르겠지만, 알아서 될거야 라는 부분이에요
하지만 개발을 하려면 알아서 되는 것은 없다고 생각하고, 늘 왜 되는 것인지 질문을 던져보는 수 밖에 없어요

얼마나 많은 왜에 대답하느냐에 따라서 얼마나 자유롭게 쓸 수 있느냐가 결정됩니다

BFC가 생성되는 조건들이 여러가지가 있는데, 그때마다 새로운 BFC가 만들어져요
제일 처음엔 Boby Tag가 작동하지만, 그 안에서 또 새로운 BFC가 발동되고 하는 식으로 눈에 보이는 엘레멘트와 상관없이 BFC라는 것이 발동되어요
IFC도 마찬가지입니다, Display Inline-Block 요소들은 IFC를 발동시키는 조건이 되어요(요건 중 하나가 블록)
그림 그리는 입장에서는 내용이 아니라, 
